# Submission Report

- Submission generated at 11/06/2025 at 21:30:48

- Machine info: Linux runnervmf2e7y 6.11.0-1018-azure #18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux

## Note to Students

Please read this report carefully before submission.
Ensure that all sections are complete and accurate.
Look for any errors in the build or test outputs.
If you find any issues, correct them before submitting.
Post any questions on the class discussion board for help.


---

## README

# Project X

- Name: John Doe
- Email: johndoe@u.boisestate.edu
- Class: 452-001

## Known Bugs or Issues

TODO: Are there any known issues?

## Experience

TODO: Describe your experience with the project (struggles, breakthroughs, etc.).

## Analysis

TODO: Provide your analysis of the results. If the assignment does not require
analysis, you can remove this section.

Here is an example of how to include a plot in your README:

![Example Image](scripts/example_plot.png)
---


## Build Output

This section was generated by running `make all` in the project root directory.

```bash
make[1]: Entering directory '/home/runner/work/cs452-p4/cs452-p4'
mkdir -p build/debug
cc -g -O0 -DDEBUG -fno-omit-frame-pointer -fsanitize=address -c src/lab.c -o build/debug/lab.c.o
mkdir -p build/debug
cc -g -O0 -DDEBUG -fno-omit-frame-pointer -fsanitize=address -c src/main.c -o build/debug/main.c.o
cc -g -O0 -DDEBUG -fno-omit-frame-pointer -fsanitize=address build/debug/lab.c.o build/debug/main.c.o -o build/debug/myapp_d -fsanitize=address
make[1]: Leaving directory '/home/runner/work/cs452-p4/cs452-p4'
make[1]: Entering directory '/home/runner/work/cs452-p4/cs452-p4'
mkdir -p build/release
cc -Wall -Wextra -O2 -fPIE -MMD -MP -Wformat -Wformat=2 -Wconversion -Wsign-conversion -Wimplicit-fallthrough -fstack-protector-strong -Werror=format-security -Werror=implicit -Werror=incompatible-pointer-types -Werror=int-conversion -c src/lab.c -o build/release/lab.c.o
mkdir -p build/release
cc -Wall -Wextra -O2 -fPIE -MMD -MP -Wformat -Wformat=2 -Wconversion -Wsign-conversion -Wimplicit-fallthrough -fstack-protector-strong -Werror=format-security -Werror=implicit -Werror=incompatible-pointer-types -Werror=int-conversion -c src/main.c -o build/release/main.c.o
cc -Wall -Wextra -O2 -fPIE -MMD -MP -Wformat -Wformat=2 -Wconversion -Wsign-conversion -Wimplicit-fallthrough -fstack-protector-strong -Werror=format-security -Werror=implicit -Werror=incompatible-pointer-types -Werror=int-conversion build/release/lab.c.o build/release/main.c.o -o build/release/myapp 
make[1]: Leaving directory '/home/runner/work/cs452-p4/cs452-p4'
make[1]: Entering directory '/home/runner/work/cs452-p4/cs452-p4'
mkdir -p build/tests
cc -g -O0 -DTEST -fprofile-arcs -ftest-coverage -c src/lab.c -o build/tests/lab.c.o
mkdir -p build/tests
cc -g -O0 -DTEST -fprofile-arcs -ftest-coverage -c src/main.c -o build/tests/main.c.o
mkdir -p build/tests/harness/
cc -g -O0 -DTEST -fprofile-arcs -ftest-coverage -c tests/harness/unity.c -o build/tests/harness/unity.c.o
mkdir -p build/tests/
cc -g -O0 -DTEST -fprofile-arcs -ftest-coverage -c tests/lab-test.c -o build/tests/lab-test.c.o
cc -g -O0 -DTEST -fprofile-arcs -ftest-coverage build/tests/lab.c.o build/tests/main.c.o build/tests/harness/unity.c.o build/tests/lab-test.c.o -o build/tests/myapp_t -fprofile-arcs -ftest-coverage
make[1]: Leaving directory '/home/runner/work/cs452-p4/cs452-p4'
make[1]: Entering directory '/home/runner/work/cs452-p4/cs452-p4'
mkdir -p build/debug-test
cc -g -O0 -DDEBUG -DTEST -fno-omit-frame-pointer -fsanitize=address -c src/lab.c -o build/debug-test/lab.c.o
mkdir -p build/debug-test
cc -g -O0 -DDEBUG -DTEST -fno-omit-frame-pointer -fsanitize=address -c src/main.c -o build/debug-test/main.c.o
mkdir -p build/debug-test/harness/
cc -g -O0 -DDEBUG -DTEST -fno-omit-frame-pointer -fsanitize=address -c tests/harness/unity.c -o build/debug-test/harness/unity.c.o
mkdir -p build/debug-test/
cc -g -O0 -DDEBUG -DTEST -fno-omit-frame-pointer -fsanitize=address -c tests/lab-test.c -o build/debug-test/lab-test.c.o
cc -g -O0 -DDEBUG -DTEST -fno-omit-frame-pointer -fsanitize=address build/debug-test/lab.c.o build/debug-test/main.c.o build/debug-test/harness/unity.c.o build/debug-test/lab-test.c.o -o build/debug-test/myapp_td -fsanitize=address
make[1]: Leaving directory '/home/runner/work/cs452-p4/cs452-p4'
Builds completed. You can run the application with: ./build/release/myapp
You can run the debug build with: ./build/debug/myapp_d
You can run the test build with: ./build/tests/myapp_t
You can run the debug-test build with: ./build/debug-test/myapp_td
```

---

## Coverage Report

This section was generated by running `make report` in the project root directory.

```bash
Setting up tests...
Tearing down tests...
tests/lab-test.c:266:test_init_with_zero_capacity_behaves_valid:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:267:test_fifo_order_and_wraparound:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:268:test_is_empty_reflects_state_with_interleaving:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:269:test_dequeue_blocks_until_item_enqueued:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:270:test_enqueue_blocks_when_full_until_space_available:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:271:test_shutdown_makes_blocked_dequeue_return_null:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:272:test_shutdown_unblocks_enqueue_and_prevents_insertion:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:273:test_enqueue_after_shutdown_is_noop_and_dequeue_returns_null_when_empty:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:274:test_multiple_producers_consumers_integrity:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:275:test_dequeue_from_empty_after_shutdown_is_immediate_null:PASS

-----------------------
10 Tests 0 Failures 0 Ignored 
OK
./build/tests/myapp_t
Setting up tests...
Tearing down tests...
tests/lab-test.c:266:test_init_with_zero_capacity_behaves_valid:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:267:test_fifo_order_and_wraparound:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:268:test_is_empty_reflects_state_with_interleaving:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:269:test_dequeue_blocks_until_item_enqueued:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:270:test_enqueue_blocks_when_full_until_space_available:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:271:test_shutdown_makes_blocked_dequeue_return_null:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:272:test_shutdown_unblocks_enqueue_and_prevents_insertion:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:273:test_enqueue_after_shutdown_is_noop_and_dequeue_returns_null_when_empty:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:274:test_multiple_producers_consumers_integrity:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:275:test_dequeue_from_empty_after_shutdown_is_immediate_null:PASS

-----------------------
10 Tests 0 Failures 0 Ignored 
OK
mkdir -p ./build/report/html
mkdir -p ./build/report/txt
gcovr -r . --html --html-details --exclude-directories build/tests/harness --exclude '.*main\.c$' --exclude '.*test\.c$' -o ./build/report/html/coverage_report.html
(INFO) Reading coverage data...

(INFO) Writing coverage report...

gcovr -r . --txt                 --exclude-directories build/tests/harness --exclude '.*main\.c$' --exclude '.*test\.c$'
(INFO) Reading coverage data...

(INFO) Writing coverage report...

------------------------------------------------------------------------------
                           GCC Code Coverage Report
Directory: .
------------------------------------------------------------------------------
File                                       Lines    Exec  Cover   Missing
------------------------------------------------------------------------------
src/lab.c                                     73      65    89%   23-24,101-106
------------------------------------------------------------------------------
TOTAL                                         73      65    89%
------------------------------------------------------------------------------
```

---

## Address Sanitizer Report

This section was generated by running `make leak-test` in the project root directory.

```bash
Setting up tests...
Tearing down tests...
tests/lab-test.c:266:test_init_with_zero_capacity_behaves_valid:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:267:test_fifo_order_and_wraparound:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:268:test_is_empty_reflects_state_with_interleaving:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:269:test_dequeue_blocks_until_item_enqueued:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:270:test_enqueue_blocks_when_full_until_space_available:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:271:test_shutdown_makes_blocked_dequeue_return_null:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:272:test_shutdown_unblocks_enqueue_and_prevents_insertion:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:273:test_enqueue_after_shutdown_is_noop_and_dequeue_returns_null_when_empty:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:274:test_multiple_producers_consumers_integrity:PASS
Setting up tests...
Tearing down tests...
tests/lab-test.c:275:test_dequeue_from_empty_after_shutdown_is_immediate_null:PASS

-----------------------
10 Tests 0 Failures 0 Ignored 
OK
```

---

## Src Files
### lab.c

```c

#include "lab.h"
#include <pthread.h>
#include <stdlib.h>

struct queue {
    void **buf;
    int capacity;
    int head;
    int tail;
    int count;
    bool shutdown;
    pthread_mutex_t mtx;
    pthread_cond_t not_full;
    pthread_cond_t not_empty;
};

queue_t queue_init(int capacity) {
    if (capacity <= 0) capacity = 1;
    struct queue *q = (struct queue *)malloc(sizeof(struct queue));
    if (!q) return NULL;
    q->buf = (void **)malloc(sizeof(void *) * (size_t)(capacity));
    if (!q->buf) {
        free(q);
        return NULL;
    }
    q->capacity = capacity;
    q->head = 0;
    q->tail = 0;
    q->count = 0;
    q->shutdown = false;
    pthread_mutex_init(&q->mtx, NULL);
    pthread_cond_init(&q->not_full, NULL);
    pthread_cond_init(&q->not_empty, NULL);
    return q;
}

void queue_destroy(queue_t q) {
    if (!q) return;
    pthread_mutex_lock(&q->mtx);
    q->shutdown = true;
    pthread_cond_broadcast(&q->not_full);
    pthread_cond_broadcast(&q->not_empty);
    pthread_mutex_unlock(&q->mtx);
    pthread_cond_destroy(&q->not_full);
    pthread_cond_destroy(&q->not_empty);
    pthread_mutex_destroy(&q->mtx);
    free(q->buf);
    free(q);
}

void enqueue(queue_t q, void *data) {
    if (!q) return;
    pthread_mutex_lock(&q->mtx);
    while (!q->shutdown && q->count == q->capacity) {
        pthread_cond_wait(&q->not_full, &q->mtx);
    }
    if (!q->shutdown) {
        q->buf[q->tail] = data;
        q->tail = (q->tail + 1) % q->capacity;
        q->count++;
        pthread_cond_signal(&q->not_empty);
    }
    pthread_mutex_unlock(&q->mtx);
}

void *dequeue(queue_t q) {
    if (!q) return NULL;
    pthread_mutex_lock(&q->mtx);
    while (!q->shutdown && q->count == 0) {
        pthread_cond_wait(&q->not_empty, &q->mtx);
    }
    if (q->count == 0 && q->shutdown) {
        pthread_mutex_unlock(&q->mtx);
        return NULL;
    }
    void *data = q->buf[q->head];
    q->head = (q->head + 1) % q->capacity;
    q->count--;
    pthread_cond_signal(&q->not_full);
    pthread_mutex_unlock(&q->mtx);
    return data;
}

void queue_shutdown(queue_t q) {
    if (!q) return;
    pthread_mutex_lock(&q->mtx);
    q->shutdown = true;
    pthread_cond_broadcast(&q->not_full);
    pthread_cond_broadcast(&q->not_empty);
    pthread_mutex_unlock(&q->mtx);
}

bool is_empty(queue_t q) {
    if (!q) return true;
    pthread_mutex_lock(&q->mtx);
    bool v = (q->count == 0);
    pthread_mutex_unlock(&q->mtx);
    return v;
}

bool is_shutdown(queue_t q) {
    if (!q) return true;
    pthread_mutex_lock(&q->mtx);
    bool v = q->shutdown;
    pthread_mutex_unlock(&q->mtx);
    return v;
}


```

### lab.h

```c

#ifndef LAB_H
#define LAB_H
#include <stdlib.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * @brief opaque type definition for a queue
     */
    typedef struct queue *queue_t;

    /**
     * @brief Initialize a new queue
     *
     * @param capacity the maximum capacity of the queue
     * @return A fully initialized queue
     */
    queue_t queue_init(int capacity);

    /**
     * @brief Frees all memory and related data signals all waiting threads.
     *
     * @param q a queue to free
     */
    void queue_destroy(queue_t q);

    /**
     * @brief Adds an element to the back of the queue
     *
     * @param q the queue
     * @param data the data to add
     */
    void enqueue(queue_t q, void *data);

    /**
     * @brief Removes the first element in the queue.
     *
     * @param q the queue
     */
    void *dequeue(queue_t q);

    /**
     * @brief Set the shutdown flag in the queue so all threads can
     * complete and exit properly
     *
     * @param q The queue
     */
   void queue_shutdown(queue_t q);

    /**
     * @brief Returns true is the queue is empty
     *
     * @param q the queue
     */
    bool is_empty(queue_t q);

    /**
     * @brief
     *
     * @param q The queue
     */
    bool is_shutdown(queue_t q);

#ifdef __cplusplus
} // extern "C"
#endif

#endif

```

### main.c

```c

#ifndef TEST
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <stdbool.h>
#include <time.h>
#include <getopt.h>
#include <sys/time.h> /* for gettimeofday system call */
#include "lab.h"

#define UNUSED(x) (void)x
#define MAX_C 8           /* Maximum number of consumer threads */
#define MAX_P 8           /* Maximum number of producer threads */
#define MAX_SLEEP 1000000 /* maximum time a thread can sleep in nanoseconds*/

static bool delay = false;

double getMilliSeconds()
{
     struct timeval now;
     gettimeofday(&now, (struct timezone *)0);
     return (double)(now.tv_sec) * 1000.0 + (double)(now.tv_usec) / 1000.0;
}

/*Track the total items produced and consumed*/
static struct
{
     unsigned int num;
     pthread_mutex_t lock;
} numproduced = {0, PTHREAD_MUTEX_INITIALIZER},
  numconsumed = {0, PTHREAD_MUTEX_INITIALIZER};

/*Shared queue that producers and consumers will access*/
static queue_t pc_queue;

/**
 * Produces items at a random interval. Exits once it has produced
 * the correct number of items.
 */
static void *producer(void *args)
{

     int num = *((int *)args);
     //pthread_t tid = pthread_self();
     unsigned int seedp = 0;
     struct timespec s = {0, 0};
     int *itm = NULL;

     // fprintf(stderr, "Producer thread: %ld - producing %d items\n", tid, num);
     for (int i = 0; i < num; i++)
     {
          if (delay)
          {
               /*simulate producing the item*/
               s.tv_nsec = (rand_r(&seedp) % MAX_SLEEP);
               nanosleep(&s, NULL);
          }

          itm = (int *)malloc(sizeof(int));
          *itm = i;
          // Put the item into the queue
          enqueue(pc_queue, itm);

          // Update counters for testing purposes
          pthread_mutex_lock(&numproduced.lock);
          numproduced.num++;
          pthread_mutex_unlock(&numproduced.lock);
     }
     // fprintf(stderr, "Producer thread: %ld - Done producing!\n", tid);
     pthread_exit(NULL);
}

/**
 * Consumes items.
 */
static void *consumer(void *args)
{
     UNUSED(args);
     //pthread_t tid = pthread_self();
     unsigned int seedp = 0;
     struct timespec s = {0, 0};
     int *itm = NULL;
     // fprintf(stderr, "Consumer thread: %ld\n", tid);

     while (true)
     {
          if (delay)
          {
               /*simulate producing the item*/
               s.tv_nsec = (rand_r(&seedp) % MAX_SLEEP);
               nanosleep(&s, NULL);
          }

          itm = (int *)dequeue(pc_queue);
          if (itm)
          {
               free(itm);
               itm = NULL;
               // Update counters for testing purposes
               pthread_mutex_lock(&numconsumed.lock);
               numconsumed.num++;
               pthread_mutex_unlock(&numconsumed.lock);
          }
          else
          {
               // If the queue is implemented correctly we should not
               // get a NULL item during normal operation. It is possible to
               // get a NULL item AFTER shutdown has been called which is fine
               // because we are just cleaning up all the items.
               if (!is_shutdown(pc_queue))
               {
                    fprintf(stderr, "ERROR: Got a null item when queue was not shutdown!\n");
               }
               break;
          }
     }
     // fprintf(stderr, "Consumer Thread: %ld - Done consuming!\n", tid);
     pthread_exit(NULL);
}

static void usage(char *n)
{
     fprintf(stderr, "Usage: %s [-c num consumer] [-p num producer] [-i num items] [-s queue size] <-d introduce delay>\n", n);
     fprintf(stderr, "-d will introduce a random delay between consumer and producer");
     exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
     int nump = 1;       /*total number of producers*/
     int numc = 1;       /*total number of consumers*/
     int numitems = 10;  /*total number of items to produce per thread*/
     int queue_size = 5; /*The default size of the queue*/
     int c;

     pthread_t producers[MAX_P];
     pthread_t consumers[MAX_C];

     while ((c = getopt(argc, argv, "c:p:i:s:dh")) != -1)
          switch (c)
          {
          case 'c':
               numc = atoi(optarg);
               break;
          case 'p':
               nump = atoi(optarg);
               ;
               break;
          case 'i':
               numitems = atoi(optarg);
               break;
          case 's':
               queue_size = atoi(optarg);
               break;
          case 'd':
               delay = true;
               break;
          case 'h':
               usage(argv[0]);
               break;
          default: /* ? */
               usage(argv[0]);
          }
     if (numc > MAX_C)
          numc = MAX_C;
     if (nump > MAX_P)
          nump = MAX_P;

     int per_thread = numitems / nump;
     fprintf(stderr, "Simulating %d producers %d consumers with %d items per thread and a queue size of %d\n", nump, numc, per_thread, queue_size);
     // Start our timing
     double end = 0;
     double start = getMilliSeconds();

     // Initialize the queue for usage
     pc_queue = queue_init(queue_size);
     /*Create the producer threads*/
     for (int i = 0; i < nump; i++)
     {
          pthread_create(&producers[i], NULL, producer, (void *)&per_thread);
     }

     fprintf(stderr, "Creating %d consumer threads\n", numc);
     /*Create the consumer threads*/
     for (int i = 0; i < numc; i++)
     {
          pthread_create(&consumers[i], NULL, consumer, (void *)NULL);
     }

     /*Wait for all the the producer threads to finish*/
     for (int i = 0; i < nump; i++)
     {
          pthread_join(producers[i], NULL);
     }

     // Once all the producers are finished we set a flag so the consumer thread can finish up
     // Once shutdown is called your queue should drain all remaining items and be read for
     // destruction!
     queue_shutdown(pc_queue);

     /*Wait for all the the consumer threads to finish*/
     for (int i = 0; i < numc; i++)
     {
          pthread_join(consumers[i], NULL);
     }

     if (numproduced.num != numconsumed.num)
     {
          fprintf(stderr, "ERROR! produced != consumed\n");
          abort();
     }
     fprintf(stderr, "Queue is empty:%s\n", is_empty(pc_queue) ? "true" : "false");
     fprintf(stderr, "Total produced:%d\n", numproduced.num);
     fprintf(stderr, "Total consumed:%d\n", numconsumed.num);

     // Free up all the stuff we allocated
     queue_destroy(pc_queue);

     // End our timing
     end = getMilliSeconds();
     // Print timing to standard out to graph
     fprintf(stdout, " %f %d \n", end - start, numproduced.num);

     return 0;
}

#endif

```

## Tests Files
### lab-test.c

```c

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#include "harness/unity.h"
#include "../src/lab.h"

static void msleep(int ms) {
    struct timespec ts;
    ts.tv_sec = ms / 1000;
    ts.tv_nsec = (ms % 1000) * 1000000L;
    nanosleep(&ts, NULL);
}

typedef struct {
    queue_t q;
    void **outp;
} dq_args_t;

typedef struct {
    queue_t q;
    void *val;
} enq_args_t;

static void *th_dequeue_capture(void *arg) {
    dq_args_t *a = (dq_args_t *)arg;
    void *v = dequeue(a->q);
    if (a->outp) *a->outp = v;
    return NULL;
}

static void *th_enqueue_value(void *arg) {
    enq_args_t *a = (enq_args_t *)arg;
    enqueue(a->q, a->val);
    return NULL;
}

typedef struct {
    queue_t q;
    int base;
    int nper;
    int *produced;
    pthread_mutex_t *mtx;
} pctx_t;

typedef struct {
    queue_t q;
    int need;
    int *consumed;
    pthread_mutex_t *mtx;
} cctx_t;

static void *prod_fn(void *arg) {
    pctx_t *c = (pctx_t *)arg;
    for (int i = 0; i < c->nper; i++) {
        int *v = (int *)malloc(sizeof(int));
        *v = c->base + i;
        enqueue(c->q, v);
        pthread_mutex_lock(c->mtx);
        (*c->produced)++;
        pthread_mutex_unlock(c->mtx);
    }
    return NULL;
}

static void *cons_fn(void *arg) {
    cctx_t *c = (cctx_t *)arg;
    int got = 0;
    while (got < c->need) {
        void *p = dequeue(c->q);
        if (p == NULL && is_shutdown(c->q)) break;
        if (p) {
            free(p);
            got++;
            pthread_mutex_lock(c->mtx);
            (*c->consumed)++;
            pthread_mutex_unlock(c->mtx);
        } else {
            msleep(1);
        }
    }
    return NULL;
}

void setUp(void) {
    printf("Setting up tests...\n");
}

void tearDown(void) {
    printf("Tearing down tests...\n");
}

void test_init_with_zero_capacity_behaves_valid(void) {
    queue_t q = queue_init(0);
    TEST_ASSERT_NOT_NULL(q);
    TEST_ASSERT_TRUE(is_empty(q));
    int v = 42;
    enqueue(q, &v);
    TEST_ASSERT_FALSE(is_empty(q));
    void *out = dequeue(q);
    TEST_ASSERT_EQUAL_PTR(&v, out);
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_fifo_order_and_wraparound(void) {
    queue_t q = queue_init(3);
    int v[6] = {1,2,3,4,5,6};
    enqueue(q, &v[0]);
    enqueue(q, &v[1]);
    enqueue(q, &v[2]);
    TEST_ASSERT_FALSE(is_empty(q));
    TEST_ASSERT_EQUAL_PTR(&v[0], dequeue(q));
    enqueue(q, &v[3]);
    TEST_ASSERT_EQUAL_PTR(&v[1], dequeue(q));
    TEST_ASSERT_EQUAL_PTR(&v[2], dequeue(q));
    TEST_ASSERT_EQUAL_PTR(&v[3], dequeue(q));
    TEST_ASSERT_TRUE(is_empty(q));
    enqueue(q, &v[4]);
    enqueue(q, &v[5]);
    TEST_ASSERT_EQUAL_PTR(&v[4], dequeue(q));
    TEST_ASSERT_EQUAL_PTR(&v[5], dequeue(q));
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_is_empty_reflects_state_with_interleaving(void) {
    queue_t q = queue_init(2);
    int a = 7, b = 8;
    TEST_ASSERT_TRUE(is_empty(q));
    enqueue(q, &a);
    TEST_ASSERT_FALSE(is_empty(q));
    enqueue(q, &b);
    TEST_ASSERT_FALSE(is_empty(q));
    (void)dequeue(q);
    TEST_ASSERT_FALSE(is_empty(q));
    (void)dequeue(q);
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_dequeue_blocks_until_item_enqueued(void) {
    queue_t q = queue_init(2);
    void *captured = (void *)0xDEAD;
    dq_args_t args = { .q = q, .outp = &captured };
    pthread_t t;
    pthread_create(&t, NULL, th_dequeue_capture, &args);
    msleep(100);
    TEST_ASSERT_EQUAL_PTR((void *)0xDEAD, captured);
    int v = 99;
    enqueue(q, &v);
    pthread_join(t, NULL);
    TEST_ASSERT_EQUAL_PTR(&v, captured);
    queue_destroy(q);
}

void test_enqueue_blocks_when_full_until_space_available(void) {
    queue_t q = queue_init(1);
    int a = 1, b = 2;
    enqueue(q, &a);
    enq_args_t args = { .q = q, .val = &b };
    pthread_t t;
    pthread_create(&t, NULL, th_enqueue_value, &args);
    msleep(100);
    void *out = dequeue(q);
    TEST_ASSERT_EQUAL_PTR(&a, out);
    pthread_join(t, NULL);
    out = dequeue(q);
    TEST_ASSERT_EQUAL_PTR(&b, out);
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_shutdown_makes_blocked_dequeue_return_null(void) {
    queue_t q = queue_init(2);
    void *captured = (void *)0xBEEF;
    dq_args_t args = { .q = q, .outp = &captured };
    pthread_t t;
    pthread_create(&t, NULL, th_dequeue_capture, &args);
    msleep(100);
    queue_shutdown(q);
    pthread_join(t, NULL);
    TEST_ASSERT_NULL(captured);
    queue_destroy(q);
}

void test_shutdown_unblocks_enqueue_and_prevents_insertion(void) {
    queue_t q = queue_init(1);
    int a = 1, b = 2;
    enqueue(q, &a);
    enq_args_t args = { .q = q, .val = &b };
    pthread_t t;
    pthread_create(&t, NULL, th_enqueue_value, &args);
    msleep(100);
    queue_shutdown(q);
    pthread_join(t, NULL);
    void *out = dequeue(q);
    TEST_ASSERT_EQUAL_PTR(&a, out);
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_enqueue_after_shutdown_is_noop_and_dequeue_returns_null_when_empty(void) {
    queue_t q = queue_init(4);
    queue_shutdown(q);
    int v = 3;
    enqueue(q, &v);
    TEST_ASSERT_TRUE(is_empty(q));
    void *out = dequeue(q);
    TEST_ASSERT_NULL(out);
    queue_destroy(q);
}

void test_multiple_producers_consumers_integrity(void) {
    queue_t q = queue_init(8);
    int produced = 0;
    int consumed = 0;
    pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    enum { NPROD = 4, NPER = 1000, NCONS = 4 };
    pthread_t prod[NPROD];
    pthread_t cons[NCONS];
    pctx_t pctxs[NPROD];
    cctx_t cctxs[NCONS];
    for (int i = 0; i < NPROD; i++) {
        pctxs[i].q = q;
        pctxs[i].base = i * 1000000;
        pctxs[i].nper = NPER;
        pctxs[i].produced = &produced;
        pctxs[i].mtx = &mtx;
        pthread_create(&prod[i], NULL, prod_fn, &pctxs[i]);
    }
    for (int i = 0; i < NCONS; i++) {
        cctxs[i].q = q;
        cctxs[i].need = (NPROD * NPER) / NCONS;
        cctxs[i].consumed = &consumed;
        cctxs[i].mtx = &mtx;
        pthread_create(&cons[i], NULL, cons_fn, &cctxs[i]);
    }
    for (int i = 0; i < NPROD; i++) pthread_join(prod[i], NULL);
    while (1) {
        pthread_mutex_lock(&mtx);
        int done = (consumed >= NPROD * NPER);
        pthread_mutex_unlock(&mtx);
        if (done) break;
        msleep(1);
    }
    queue_shutdown(q);
    for (int i = 0; i < NCONS; i++) pthread_join(cons[i], NULL);
    TEST_ASSERT_EQUAL_INT(NPROD * NPER, produced);
    TEST_ASSERT_EQUAL_INT(NPROD * NPER, consumed);
    TEST_ASSERT_TRUE(is_empty(q));
    queue_destroy(q);
}

void test_dequeue_from_empty_after_shutdown_is_immediate_null(void) {
    queue_t q = queue_init(2);
    queue_shutdown(q);
    void *v = dequeue(q);
    TEST_ASSERT_NULL(v);
    queue_destroy(q);
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_init_with_zero_capacity_behaves_valid);
    RUN_TEST(test_fifo_order_and_wraparound);
    RUN_TEST(test_is_empty_reflects_state_with_interleaving);
    RUN_TEST(test_dequeue_blocks_until_item_enqueued);
    RUN_TEST(test_enqueue_blocks_when_full_until_space_available);
    RUN_TEST(test_shutdown_makes_blocked_dequeue_return_null);
    RUN_TEST(test_shutdown_unblocks_enqueue_and_prevents_insertion);
    RUN_TEST(test_enqueue_after_shutdown_is_noop_and_dequeue_returns_null_when_empty);
    RUN_TEST(test_multiple_producers_consumers_integrity);
    RUN_TEST(test_dequeue_from_empty_after_shutdown_is_immediate_null);
    return UNITY_END();
}


```

## Scripts Files
Report generated on 11/06/2025 at 21:30:51


---

## End of Report

SHA-256 Hash of the report: 1fedb402fb45149b18ca5ae9d9620d68926fe5c3fea0d5614fa40fb6a47a6050

Do not edit the generated report. Any changes will be reported as academic dishonesty

---
## GitHub Info
- GitHub repo name: benjaminblodgett311/cs452-p4
- The repository visibility is public.
- The workflow was triggered by benjaminblodgett311
